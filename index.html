<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIPOCA.I - Agente de Filmes com IA</title>
    <!-- Tailwind CSS CDN para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fontes Google para a estética do aplicativo -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;700&family=Rubik+Pixels&display=swap" rel="stylesheet">
    <style>
        /* Estilos globais do corpo da página */
        body {
            background-color: #110f10; /* Cor de fundo escura */
            color: #d9d4c8; /* Cor do texto clara */
            font-family: 'Poppins', sans-serif; /* Fonte principal */
        }

        /* Efeito de granulado sutil no fundo */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='); /* Pixel transparente */
            opacity: 0.15;
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: -1;
        }

        /* Estilo para a fonte do título "PIPOCA.I" */
        .font-pixel {
            font-family: 'Rubik Pixels', sans-serif;
        }

        /* Estilo para a fonte principal */
        .font-main {
            font-family: 'Poppins', sans-serif;
        }

        /* Efeito de brilho para o título "PIPOCA.I" */
        .pipoca-glow {
            text-shadow: 0 0 15px rgba(217, 212, 200, 0.2), 0 0 25px rgba(217, 212, 200, 0.1);
        }

        /* Estilos para o campo de input de prompt */
        .prompt-input {
            background-color: transparent;
            border: 1px solid #d9d4c8;
            border-radius: 9999px; /* Borda arredondada (pill shape) */
            padding: 0.75rem 1.5rem;
            color: #d9d4c8;
            width: 100%;
            text-transform: uppercase;
            font-weight: 300;
        }
        .prompt-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .prompt-input::placeholder {
            color: #8a867d;
        }
        .prompt-input:focus {
            outline: none;
            border-color: #fff;
        }

        /* Estilos para os botões da IA */
        .ai-button {
            background-color: transparent;
            border: none;
            color: #d9d4c8;
            font-weight: 700;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: color 0.3s;
        }
        .ai-button:hover {
            color: #fff;
        }
        .ai-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Estilos para os cards de filme (aesthetic Apple clean) */
        .movie-card {
            border: 1px solid rgba(217, 212, 200, 0.3); /* Borda suave e translúcida */
            border-radius: 1.5rem;
            padding: 1.5rem;
            background-color: rgba(17, 15, 16, 0.6); /* Fundo semi-transparente */
            backdrop-filter: blur(8px); /* Efeito de blur no fundo */
            height: 100%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Sombra sutil */
            transition: transform 0.2s ease-in-out; /* Transição para efeito hover */
        }
        .movie-card:hover {
            transform: translateY(-5px); /* Efeito de elevação ao passar o mouse */
        }
        
        /* Estilos para o pôster do filme */
        .movie-poster {
            width: 100%;
            max-width: 100px; /* Pôster menor */
            height: auto;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            object-fit: cover;
            align-self: center; /* Centraliza o pôster no card */
        }

        /* Classe utilitária para esconder elementos */
        .hidden {
            display: none;
        }

        /* Animação de fade-in */
        .fade-in {
            animation: fadeInAnimation 0.7s ease-in-out;
        }
        @keyframes fadeInAnimation {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Estilos para os grupos de filtro (botões de rádio) */
        .filter-group label {
            padding: 0.5rem 1rem;
            border: 1px solid #d9d4c8;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 0.75rem;
        }
        .filter-group input[type="radio"]:checked + label {
            background-color: #d9d4c8;
            color: #110f10;
        }
        .filter-group input[type="radio"] {
            display: none;
        }

        /* Estilos para o Modal de "Ler Mais" */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #110f10;
            color: #d9d4c8;
            padding: 2rem;
            border-radius: 1.5rem;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #d9d4c8;
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased font-main">

    <div id="app-container" class="min-h-screen w-full flex flex-col items-center justify-center p-4 lg:p-8">

        <!-- Tela 1: Boas-vindas -->
        <div id="screen1" class="w-full h-full flex flex-col items-center justify-center text-center fade-in">
            <p class="font-main font-bold text-sm tracking-widest mb-4">FIND YOUR MOVIE</p>
            <h1 class="font-pixel text-7xl md:text-9xl my-4 pipoca-glow">PIPOCA.I</h1>
            <button id="start-button" class="ai-button font-main text-sm tracking-widest mt-8">CLICK HERE TO ASK THE AI</button>
        </div>

        <!-- Tela 2 & 3: Conteúdo Principal -->
        <div id="main-content" class="w-full max-w-6xl hidden">
            <header class="w-full flex justify-between items-center mb-12">
                <h2 class="font-pixel text-3xl md:text-4xl pipoca-glow">PIPOCA.I</h2>
                <p class="font-main font-bold text-xs tracking-widest">FIND YOUR MOVIE</p>
            </header>

            <!-- Seção de Prompt e Filtros -->
            <div id="prompt-section" class="w-full text-center mb-8 relative">
                 <p class="font-main text-sm tracking-widest uppercase">This is an AI Agent</p>
                <p class="font-main text-lg mt-2 uppercase">
                    <strong class="font-bold">Describe the type of movie you want to watch</strong>
                </p>

                <div class="mt-6 max-w-3xl mx-auto flex items-center gap-4">
                    <input type="text" id="prompt-input" class="prompt-input font-main" placeholder="E.G., A SLAPSTICK COMEDY LIKE AMERICAN PIE">
                    <button id="search-button" class="ai-button font-main text-sm tracking-widest">SEARCH</button>
                </div>

                <!-- Botão para abrir/fechar o modal de filtro -->
                <div class="flex justify-center my-6">
                    <button id="filter-toggle-button" class="ai-button font-main text-sm tracking-widest">FILTER</button>
                </div>

                <!-- Modal/Dropdown de Filtro -->
                <div id="filter-modal" class="hidden absolute top-full mt-2 left-1/2 -translate-x-1/2 bg-[#110f10] p-6 rounded-xl shadow-lg z-20 border border-[#d9d4c8] w-11/12 md:w-auto">
                    <div class="flex flex-col md:flex-row justify-center items-center gap-4 md:gap-8 my-6">
                        <div class="filter-group flex flex-wrap justify-center gap-2">
                            <input type="radio" id="rotten" name="source" value="Rotten Tomatoes" checked>
                            <label for="rotten">Rotten Tomatoes</label>
                            <input type="radio" id="imdb" name="source" value="IMDB">
                            <label for="imdb">IMDB</label>
                            <input type="radio" id="letterboxd" name="source" value="Letterboxd">
                            <label for="letterboxd">Letterboxd</label>
                        </div>
                        <div class="filter-group flex flex-wrap justify-center gap-2">
                            <input type="radio" id="no_pref" name="preference" value="none" checked>
                            <label for="no_pref">No Preference</label>
                            <input type="radio" id="critic" name="preference" value="CRITIC'S FAVORITE">
                            <label for="critic">Critic's Favorite</label>
                            <input type="radio" id="public" name="preference" value="PUBLIC'S FAVORITE">
                            <label for="public">Public's Favorite</label>
                        </div>
                    </div>
                    <div class="text-center mt-4">
                        <button id="close-filter-button" class="ai-button font-main text-sm tracking-widest">APPLY FILTERS</button>
                    </div>
                </div>
            </div>
            
            <!-- Seção de Resultados -->
            <div id="results-section" class="w-full mt-12 flex flex-col items-center">
                <div id="loader" class="text-center hidden"><p class="font-main tracking-widest">SEARCHING FOR MOVIES...</p></div>
                <!-- Grade de resultados centralizada e responsiva -->
                <div id="results-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 items-start mx-auto">
                    <!-- Cards e botão "SEARCH MORE" serão injetados aqui -->
                </div>
                <div id="error-message" class="text-center hidden font-main text-red-400 mt-4"></div>
            </div>
        </div>
    </div>

    <!-- Modal para "Ler Mais" (comentários longos) -->
    <div id="read-more-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="modal-close-button" class="modal-close-button">&times;</button>
            <h3 id="modal-title-comment" class="font-bold text-lg mb-4"></h3>
            <p id="modal-comment-text" class="font-light text-sm leading-relaxed normal-case"></p>
        </div>
    </div>

    <script>
        // --- ESTADO DA APLICAÇÃO ---
        let currentPrompt = '';
        let displayedMovies = [];
        const COMMENT_TRUNCATE_LENGTH = 180; // Limite de caracteres para o comentário antes de "Ler Mais"
        let appDisplayLanguage = 'pt'; // Idioma padrão para exibição (normalizado para 'pt' ou 'en')

        // --- CONSTANTES DE API ---
        const OMDB_KEY = '62986a1f'; 
        const TMDB_KEY = '188491e52fd2bdc583bba0b7a90bfda3'; 
        // >>>>>> Gemini: placeholder será trocado pelo workflow (sed) no deploy <<<<<<
        const GEMINI_API_KEY = '__GEMINI_API_KEY__';
        const WATCHMODE_API_KEY = 'Fc6ndanwCdU4wKQYbCLZLht8x79SfZFCp765TUTT'; 

        // --- ELEMENTOS DO DOM ---
        const screen1 = document.getElementById('screen1');
        const mainContent = document.getElementById('main-content');
        const startButton = document.getElementById('start-button');
        const searchButton = document.getElementById('search-button');
        const promptInput = document.getElementById('prompt-input');
        const resultsGrid = document.getElementById('results-grid');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const filterToggleButton = document.getElementById('filter-toggle-button');
        const filterModal = document.getElementById('filter-modal');
        const closeFilterButton = document.getElementById('close-filter-button');
        const readMoreModal = document.getElementById('read-more-modal');
        const modalCloseButton = document.getElementById('modal-close-button');
        const modalCommentText = document.getElementById('modal-comment-text');
        const modalTitleComment = document.getElementById('modal-title-comment');


        // --- NAVEGAÇÃO E INICIALIZAÇÃO ---
        startButton.addEventListener('click', () => {
            screen1.classList.add('hidden');
            mainContent.classList.remove('hidden');
            mainContent.classList.add('fade-in');
            checkApiKeys(); // Verifica as chaves da API ao iniciar
        });

        function checkApiKeys() {
            if (!OMDB_KEY || OMDB_KEY === '') {
                searchButton.disabled = true;
                promptInput.disabled = true;
                filterToggleButton.disabled = true;
                promptInput.placeholder = "CHAVE DA API OMDB AUSENTE";
                showError("Erro: Chave da API OMDb não configurada. A funcionalidade de busca está desabilitada.");
            } else {
                searchButton.disabled = false;
                promptInput.disabled = false;
                filterToggleButton.disabled = false;
                promptInput.placeholder = "E.G., A SLAPSTICK COMEDY LIKE AMERICAN PIE";
                errorMessage.classList.add('hidden'); 
            }
            if (!GEMINI_API_KEY || GEMINI_API_KEY === '__GEMINI_API_KEY__') {
                console.warn("GEMINI_API_KEY não está injetada. O passo de IA pode falhar.");
            }
        }

        // --- LÓGICA DE BUSCA ---
        searchButton.addEventListener('click', () => {
            const prompt = promptInput.value;
            if (prompt.trim() === '') {
                showError('Por favor, insira uma descrição para o filme.');
                return;
            }
            currentPrompt = prompt;
            displayedMovies = []; // Reseta os filmes já exibidos para uma nova busca
            resultsGrid.innerHTML = ''; // Limpa a grade de resultados
            fetchAndDisplayMovies();
        });
        
        promptInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') searchButton.click();
        });

        // --- LÓGICA DO FILTRO ---
        filterToggleButton.addEventListener('click', () => {
            filterModal.classList.toggle('hidden');
        });

        closeFilterButton.addEventListener('click', () => {
            filterModal.classList.add('hidden');
            if (currentPrompt.trim() !== '') {
                searchButton.click();
            }
        });

        // --- Lógica do Modal "Ler Mais" ---
        modalCloseButton.addEventListener('click', () => {
            readMoreModal.classList.add('hidden');
        });

        resultsGrid.addEventListener('click', (event) => {
            if (event.target.classList.contains('read-more-button')) {
                const fullComment = event.target.dataset.fullComment;
                modalCommentText.textContent = fullComment;
                modalTitleComment.textContent = displayLabels[appDisplayLanguage].fullCommentTitle; // Atualiza o título do modal
                readMoreModal.classList.remove('hidden');
            }
        });


        async function fetchAndDisplayMovies() {
            loader.classList.remove('hidden'); // Mostra o loader
            errorMessage.classList.add('hidden'); // Esconde mensagens de erro anteriores
            document.getElementById('search-more-container')?.remove(); // Remove o botão "Search More" anterior

            try {
                const newMovies = await fetchMovieResults(currentPrompt, displayedMovies);
                loader.classList.add('hidden'); // Esconde o loader
                if (newMovies && newMovies.length > 0) {
                    // Adiciona os novos filmes à lista de filmes já exibidos
                    displayedMovies.push(...newMovies.map(m => m.nome_do_filme));
                    renderMovies(newMovies); // Renderiza os novos filmes
                } else {
                    showError("Desculpe, não foi possível encontrar mais filmes que correspondam à sua descrição.");
                }
            } catch (error) {
                console.error("Erro na busca:", error);
                loader.classList.add('hidden');
                showError('Ocorreu um erro durante a busca. Por favor, tente novamente.');
            }
        }

        function renderMovies(movies) {
            let cardsHtml = movies.map(createMovieCard).join('');
            resultsGrid.innerHTML += cardsHtml;
            
            // Cria e adiciona o botão "SEARCH MORE OPTIONS"
            const searchMoreContainer = document.createElement('div');
            searchMoreContainer.id = 'search-more-container';
            searchMoreContainer.className = 'h-full flex items-center justify-center font-main text-sm uppercase fade-in col-span-full';
            searchMoreContainer.innerHTML = `<button id="search-more-button" class="ai-button tracking-widest text-center">${displayLabels[appDisplayLanguage].searchMoreOptions}</button>`;
            resultsGrid.appendChild(searchMoreContainer);

            // Adiciona event listener ao novo botão "Search More"
            document.getElementById('search-more-button').addEventListener('click', fetchAndDisplayMovies);
        }

        /**
         * Exibe uma mensagem de erro na interface.
         * @param {string} message - A mensagem de erro a ser exibida.
         */
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        // Objeto de rótulos para diferentes idiomas
        const displayLabels = {
            'pt': { 
                released: 'LANÇAMENTO',
                whereToWatch: 'ONDE ASSISTIR',
                font: 'FONTE',
                criticRating: 'NOTA CRÍTICA',
                audienceRating: 'NOTA PÚBLICO',
                topComment: 'PRINCIPAL COMENTÁRIO',
                readMore: 'Ler Mais',
                fullCommentTitle: 'Comentário Completo',
                searchMoreOptions: 'BUSCAR<br>MAIS<br>OPÇÕES'
            },
            'en': {
                released: 'RELEASED',
                whereToWatch: 'WHERE TO WATCH',
                font: 'FONT',
                criticRating: 'CRITIC RATING',
                audienceRating: 'AUDIENCE RATING',
                topComment: 'TOP COMMENT',
                readMore: 'Read More',
                fullCommentTitle: 'Full Comment',
                searchMoreOptions: 'SEARCH<br>MORE<br>OPTIONS'
            }
        };

        /**
         * Cria o HTML para um único card de filme.
         * @param {Object} movie - Objeto contendo os dados do filme.
         * @returns {string} HTML do card do filme.
         */
        function createMovieCard(movie) {
            const currentLabels = displayLabels[appDisplayLanguage] || displayLabels['pt']; // Fallback para português
            
            let sourceName = 'N/A';
            if (movie.url_da_fonte.includes('imdb')) {
                sourceName = 'IMDB';
            } else if (movie.url_da_fonte.includes('rottentomatoes')) {
                sourceName = 'Rotten Tomatoes';
            } else if (movie.url_da_fonte.includes('letterboxd')) {
                sourceName = 'Letterboxd';
            }

            // Define a URL do pôster ou um placeholder se não houver pôster válido
            const posterUrl = movie.poster_url && movie.poster_url !== 'N/A' ? movie.poster_url : 'https://placehold.co/100x150/110f10/d9d4c8?text=NO+POSTER';

            let criticRatingHtml = '';
            // Exibe a nota do crítico apenas se a fonte não for Letterboxd
            if (sourceName !== 'Letterboxd') { 
                criticRatingHtml = `
                    <div class="px-1">
                        <p class="font-light text-[0.6rem] leading-tight">${currentLabels.criticRating}</p>
                        <p class="font-bold text-2xl">${movie.nota_critica || 'N/A'}</p>
                    </div>
                `;
            }

            // Lógica para truncar o comentário e adicionar botão "Ler Mais"
            const fullComment = movie.primeiro_comentario || 'No comment found.';
            let displayedComment = fullComment;
            let readMoreButtonHtml = '';

            if (fullComment.length > COMMENT_TRUNCATE_LENGTH) {
                displayedComment = fullComment.substring(0, COMMENT_TRUNCATE_LENGTH) + '...';
                readMoreButtonHtml = `<button class="read-more-button text-xs text-blue-400 hover:text-blue-200 ml-1 normal-case" data-full-comment="${fullComment}">${currentLabels.readMore}</button>`;
            }

            // Adiciona a seção "Where to Watch" se houver dados
            const whereToWatchHtml = movie.where_to_watch && movie.where_to_watch !== 'N/A' ? 
                `<p class="text-xs font-light mb-4">${currentLabels.whereToWatch}: <span class="font-bold">${movie.where_to_watch}</span></p>` : '';


            return `
                <div class="movie-card flex flex-col font-main text-sm uppercase fade-in">
                    <img src="${posterUrl}" alt="Poster do filme ${movie.nome_do_filme}" class="movie-poster" onerror="this.onerror=null;this.src='https://placehold.co/100x150/110f10/d9d4c8?text=NO+POSTER';">
                    <div class="flex flex-col">
                        <h3 class="font-bold text-lg mb-1">${movie.nome_do_filme || 'N/A'}</h3>
                        <p class="text-xs font-light mb-4">${currentLabels.released}: ${movie.quando_foi_lancado || 'N/A'}</p>
                        ${whereToWatchHtml} <!-- Inserido aqui -->
                        <div class="my-4 text-xs">
                            <span class="font-light">${currentLabels.font}: </span>
                            <a href="${movie.url_da_fonte || '#'}" target="_blank" rel="noopener noreferrer" class="font-bold underline hover:text-white transition-colors">${sourceName}</a>
                        </div>
                        <div class="flex justify-around mb-4 text-center">
                            ${criticRatingHtml}
                            <div class="px-1">
                                <p class="font-light text-[0.6rem] leading-tight">${currentLabels.audienceRating}</p>
                                <p class="font-bold text-2xl">${movie.nota_audiencia || 'N/A'}</p>
                            </div>
                        </div>
                    </div>
                    <div>
                        <p class="font-light mb-2">${currentLabels.topComment}</p>
                        <p class="font-light text-xs leading-relaxed normal-case">“${displayedComment}”${readMoreButtonHtml}</p>
                    </div>
                </div>
            `;
        }

        /**
         * Orquestra a busca de filmes usando **Gemini** para sugestões (antes era Groq),
         * OMDb para detalhes, TMDB para reviews e Watchmode para onde assistir.
         * @param {string} prompt - A descrição do filme fornecida pelo usuário.
         * @param {Array<string>} excludeTitles - Títulos já exibidos para evitar duplicatas.
         * @returns {Promise<Array<Object>>}
         */
        async function fetchMovieResults(prompt, excludeTitles) {
            const moviesToReturn = [];
            const sourceFilter = document.querySelector('input[name="source"]:checked').value;
            const preferenceFilter = document.querySelector('input[name="preference"]:checked').value;

            // Verificações iniciais
            if (!OMDB_KEY) {
                console.error("OMDB_KEY não está configurada.");
                return [];
            }
            if (!TMDB_KEY) {
                console.warn("TMDB_KEY não configurada. Não será possível buscar reviews do TMDB.");
            }
            if (!WATCHMODE_API_KEY) {
                console.warn("WATCHMODE_API_KEY não configurada. Não será possível buscar onde assistir.");
            }

            // --- PASSO 1: Usar **Gemini API** para gerar títulos e detectar idioma ---
            let suggestedTitles = [];
            try {
                const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

                const systemText = [
                    'Analise o idioma da descrição do usuário.',
                    'Responda APENAS JSON válido no formato:',
                    '{"language":"pt|en","titles":["t1","t2","t3","t4"]}',
                    'Sugira 4–6 filmes REAIS e populares o suficiente para existir no TMDB/OMDb.'
                ].join(' ');

                const body = {
                    systemInstruction: { parts: [{ text: systemText }] },
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                language: { type: "STRING" },
                                titles: { type: "ARRAY", items: { type: "STRING" } }
                            },
                            required: ["titles"]
                        }
                    }
                };

                const geminiResp = await fetch(geminiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!geminiResp.ok) {
                    const errorText = await geminiResp.text();
                    throw new Error(`Erro da API Gemini: ${geminiResp.status}. Corpo: ${errorText}`);
                }

                const data = await geminiResp.json();
                const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";
                const parsed = JSON.parse(text);

                if (parsed.language) {
                    appDisplayLanguage = parsed.language.toLowerCase().includes('pt') ? 'pt' : 'en';
                }
                if (parsed.titles && Array.isArray(parsed.titles)) {
                    suggestedTitles = parsed.titles;
                } else {
                    console.warn("A resposta do Gemini não continha um array 'titles'.");
                    suggestedTitles = [prompt];
                }
            } catch (err) {
                console.error("Erro ao chamar a API Gemini:", err);
                suggestedTitles = [prompt]; 
            }

            if (suggestedTitles.length === 0) {
                return [];
            }

            // --- PASSO 2: Usar os títulos sugeridos para buscar detalhes nas APIs ---
            let moviesFoundCount = 0;
            for (const title of suggestedTitles) {
                if (moviesFoundCount >= 4) break; // Limita a 4 filmes no total por busca

                // 2.1 OMDb API: Busca por título exato para obter detalhes e IMDb ID
                const omdbDetailUrl = `https://www.omdbapi.com/?t=${encodeURIComponent(title)}&type=movie&apikey=${OMDB_KEY}&tomatoes=true`;
                const omdbDetailResponse = await fetch(omdbDetailUrl);
                const omdbDetailData = await omdbDetailResponse.json();

                if (omdbDetailData.Response === "False" || excludeTitles.includes(omdbDetailData.Title)) {
                    continue; // Pula se não encontrar ou se o filme já foi exibido
                }

                // 2.2 TMDB API: Obter ID do filme TMDB para reviews (usando IMDb ID)
                let tmdbReviewContent = 'N/A';
                if (TMDB_KEY) {
                    const tmdbFindUrl = `https://api.themoviedb.org/3/find/${omdbDetailData.imdbID}?api_key=${TMDB_KEY}&external_source=imdb_id`;
                    const tmdbFindResponse = await fetch(tmdbFindUrl);
                    const tmdbFindData = await tmdbFindResponse.json();

                    if (tmdbFindData.movie_results && tmdbFindData.movie_results.length > 0) {
                        const tmdbMovieId = tmdbFindData.movie_results[0].id;
                        const tmdbReviewsUrl = `https://api.themoviedb.org/3/movie/${tmdbMovieId}/reviews?api_key=${TMDB_KEY}`;
                        const tmdbReviewsResponse = await fetch(tmdbReviewsUrl);
                        const tmdbReviewsData = await tmdbReviewsResponse.json();
                        if (tmdbReviewsData.results && tmdbReviewsData.results.length > 0) {
                            tmdbReviewContent = tmdbReviewsData.results[0].content;
                        }
                    }
                }

                // 2.3 Watchmode API: Obter informações de onde assistir (streaming)
                let whereToWatch = 'N/A';
                if (WATCHMODE_API_KEY && omdbDetailData.imdbID) {
                    const watchmodeUrl = `https://api.watchmode.com/v1/title/${omdbDetailData.imdbID}/details/?apiKey=${WATCHMODE_API_KEY}&append_to_response=sources`;
                    try {
                        const watchmodeResponse = await fetch(watchmodeUrl);
                        const watchmodeData = await watchmodeResponse.json();

                        if (watchmodeData.sources && watchmodeData.sources.length > 0) {
                            // Ajuste de região se quiser BR:
                            const streamingSources = watchmodeData.sources
                                .filter(source => 
                                    (source.type === 'sub' || source.type === 'buy' || source.type === 'rent') &&
                                    source.region === 'US' // troque para 'BR' se quiser Brasil
                                )
                                .map(source => source.name)
                                .filter((value, index, self) => self.indexOf(value) === index);

                            if (streamingSources.length > 0) {
                                whereToWatch = streamingSources.join(', ');
                            }
                        }
                    } catch (watchmodeError) {
                        console.error("Erro ao buscar onde assistir na Watchmode API:", watchmodeError);
                    }
                }

                // 2.4 Preparar dados do filme no formato solicitado
                let notaCritica = 'N/A';
                let notaAudiencia = 'N/A';
                let urlDaFonte = `https://www.imdb.com/title/${omdbDetailData.imdbID}/`;
                const posterUrl = omdbDetailData.Poster || 'N/A';

                if (sourceFilter === 'IMDB') {
                    notaCritica = omdbDetailData.Metascore || 'N/A';
                    notaAudiencia = omdbDetailData.imdbRating || 'N/A';
                } else if (sourceFilter === 'Rotten Tomatoes') {
                    const rtRating = omdbDetailData.Ratings?.find(r => r.Source === 'Rotten Tomatoes');
                    notaCritica = rtRating ? rtRating.Value : 'N/A';
                    notaAudiencia = omdbDetailData.imdbRating || 'N/A'; 
                } else if (sourceFilter === 'Letterboxd') {
                    notaCritica = 'N/A'; // Conforme solicitado
                    notaAudiencia = omdbDetailData.imdbRating || 'N/A';
                    urlDaFonte = `https://letterboxd.com/imdb/${omdbDetailData.imdbID}`;
                }

                moviesToReturn.push({
                    "nome_do_filme": omdbDetailData.Title || 'N/A',
                    "quando_foi_lancado": omdbDetailData.Year || 'N/A',
                    "nota_critica": notaCritica,
                    "nota_audiencia": notaAudiencia,
                    "primeiro_comentario": tmdbReviewContent,
                    "url_da_fonte": urlDaFonte,
                    "poster_url": posterUrl,
                    "where_to_watch": whereToWatch
                });
                moviesFoundCount++;
            }

            // --- PASSO 3: Ordenar os filmes com base na preferência e retornar ---
            if (preferenceFilter !== 'none' && moviesToReturn.length > 1) {
                moviesToReturn.sort((a, b) => {
                    let valA = 0, valB = 0;
                    if (preferenceFilter === "CRITIC'S FAVORITE") {
                        valA = parseFloat(a.nota_critica.replace('%', '')) || 0;
                        valB = parseFloat(b.nota_critica.replace('%', '')) || 0;
                    } else { // PUBLIC'S FAVORITE
                        valA = parseFloat(a.nota_audiencia) || 0;
                        valB = parseFloat(b.nota_audiencia) || 0;
                    }
                    return valB - valA; // Ordem decrescente
                });
            }
            return moviesToReturn;
        }
    </script>
</body>
</html>
